name: DNSControl Preview

on:
  pull_request:
    branches: [main]

# Cancel in-progress runs for the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  id-token: write

jobs:
  validate:
    name: Validate
    uses: ./.github/workflows/_reusable-validate.yml

  prepare:
    name: Build
    needs: validate
    uses: ./.github/workflows/prepare.yml

  preview:
    name: Preview DNS Changes
    needs: [validate, prepare]
    runs-on: ubuntu-latest
    outputs:
      preview-report: ${{ steps.preview.outputs.preview-report }}
      has-changes: ${{ steps.preview.outputs.has-changes }}
      changes-summary: ${{ steps.parse-changes.outputs.summary }}
      domain-summary: ${{ steps.parse-changes.outputs.domain-summary }}
      changes-data: ${{ steps.parse-changes.outputs.changes-data }}
      base-domains: ${{ steps.parse-changes.outputs.base-domains }}
    steps:
      - name: Download DNSControl binaries
        uses: actions/download-artifact@v4
        with:
          name: bin
          path: bin

      - name: Download compiled JS
        uses: actions/download-artifact@v4
        with:
          name: out
          path: out

      - name: Make binaries executable
        run: chmod +x dnscontrol-*
        working-directory: bin
        shell: bash

      - name: Preview DNS changes
        id: preview
        working-directory: out
        shell: bash
        env:
          CF_API: ${{ secrets.CF_API }}
        run: |
          set +e
          OUTPUT=$(../bin/dnscontrol-Linux --diff2 preview --report ../report.json 2>&1)
          EXIT_CODE=$?
          set -e

          # Save output to file for artifact upload (avoids "Argument list too long" error)
          echo "$OUTPUT" > ../preview-output.txt

          # Save JSON report if it exists
          if [ -f "../report.json" ]; then
            REPORT=$(cat ../report.json)
            echo "preview-report<<EOF" >> $GITHUB_OUTPUT
            echo "$REPORT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "preview-report=[]" >> $GITHUB_OUTPUT
          fi

          # Check if there are changes
          if echo "$OUTPUT" | grep -qE "CREATING|MODIFY|DELETE|\+ CREATE|\- DELETE|¬± MODIFY"; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

          # Print output to logs
          echo "$OUTPUT"

          # Exit with original code
          exit $EXIT_CODE

      - name: Parse DNS changes
        id: parse-changes
        if: always()
        shell: bash
        run: |
          # Parse the preview output to create a structured changes table
          # Read from file to avoid "Argument list too long" error with large outputs

          # Strip ANSI color codes from output for parsing
          # DNSControl outputs colored text which breaks grep patterns
          if [ -f "preview-output.txt" ]; then
            CLEAN_OUTPUT=$(cat preview-output.txt | sed 's/\x1b\[[0-9;]*m//g')
          else
            CLEAN_OUTPUT=""
          fi

          # Count changes by type (handle empty/missing output)
          if [ -z "$CLEAN_OUTPUT" ]; then
            CREATE_COUNT=0
            MODIFY_COUNT=0
            DELETE_COUNT=0
          else
            CREATE_COUNT=$(echo "$CLEAN_OUTPUT" | grep -cE "^#[0-9]+: \+ CREATE" || echo 0)
            MODIFY_COUNT=$(echo "$CLEAN_OUTPUT" | grep -cE "^#[0-9]+: ¬± MODIFY" || echo 0)
            DELETE_COUNT=$(echo "$CLEAN_OUTPUT" | grep -cE "^#[0-9]+: - DELETE" || echo 0)
          fi
          TOTAL_COUNT=$((CREATE_COUNT + MODIFY_COUNT + DELETE_COUNT))

          # Create summary (compact format: ‚ûï 53 / ‚úèÔ∏è 78 / üóëÔ∏è 47)
          if [ "$TOTAL_COUNT" -gt 0 ]; then
            PARTS=""
            [ "$CREATE_COUNT" -gt 0 ] && PARTS="‚ûï $CREATE_COUNT"
            [ "$MODIFY_COUNT" -gt 0 ] && PARTS="${PARTS:+$PARTS / }‚úèÔ∏è $MODIFY_COUNT"
            [ "$DELETE_COUNT" -gt 0 ] && PARTS="${PARTS:+$PARTS / }üóëÔ∏è $DELETE_COUNT"
            SUMMARY="$PARTS"
          else
            SUMMARY="No changes"
          fi
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT

          # Function to simplify long record type names for display
          simplify_type() {
            local type="$1"
            case "$type" in
              CLOUDFLAREAPI_SINGLE_REDIRECT) echo "REDIRECT" ;;
              CLOUDFLAREAPI_*) echo "${type#CLOUDFLAREAPI_}" ;;
              *) echo "$type" ;;
            esac
          }

          # Function to clean value based on record type and domain
          clean_value() {
            local type="$1"
            local value="$2"
            local domain="$3"

            # Strip trailing ttl= and id= metadata
            local clean_val=$(echo "$value" | sed -E 's/[[:space:]]+(ttl|id)=[^[:space:]]*//g' | sed 's/[[:space:]]*$//')

            # Check for challenge/verification records (hide sensitive tokens)
            # 1. Check domain-based patterns
            if echo "$domain" | grep -qiE "^_acme-challenge|^_dmarc-challenge|^_amazonses|^_google-site-verification|^_github-challenge|^_github-pages|^_atproto|^_dnslink|^_cf-custom-hostname"; then
              echo "\`<Challenge/Verification>\`"
              return
            fi
            # 2. Check value-based patterns (verification tokens in TXT records)
            if [ "$type" = "TXT" ]; then
              # Known verification prefixes
              if echo "$clean_val" | grep -qiE "^(google-site-verification|facebook-domain-verification|apple-domain-verification|adobe-idp-site-verification|atlassian-domain-verification|stripe-verification|webflow-site-verification|keybase-site-verification|brave-ledger-verification|notion-domain-verification|have-i-been-pwned-verification|docusign|msvalidate\.01|ZOOM_verify_|postmark-verification|brevo-code:|sendinblue-code:|bluesky-verification|cisco-ci-domain-verification|onetrust-domain-verification|miro-verification|hubspot-developer-verification|smartsheet-site-verification|pinterest-site-verification|yandex-verification|_globalsign-domain-verification|globalsign-domain-verification|logmein-verification-code|status-page-domain-verification|slack-domain-verification|workplace-domain-verification|canva-site-verification|ahrefs-site-verification|mongodb-site-verification)="; then
                echo "\`<Verification Token>\`"
                return
              fi
              # Detect random-looking tokens (base64/hex strings without known prefixes)
              # Skip if it looks like SPF, DKIM, or DMARC
              if ! echo "$clean_val" | grep -qE "^v=(spf1|DKIM1|DMARC1)"; then
                # Check for pure base64-like or hex-like strings (32+ chars, alphanumeric only)
                if echo "$clean_val" | grep -qE "^[A-Za-z0-9+/=_-]{32,}$"; then
                  echo "\`<Verification Token>\`"
                  return
                fi
              fi
            fi

            case "$type" in
              # For A, AAAA, CNAME: strip everything after first space (removes proxy=, ttl=, etc.)
              A|AAAA|CNAME)
                echo "$value" | awk '{print $1}'
                ;;
              # For MX records: parse priority and target
              MX)
                # MX format is typically: priority target (e.g., "10 mail.example.com.")
                local priority=$(echo "$clean_val" | awk '{print $1}')
                local target=$(echo "$clean_val" | awk '{print $2}')
                if [ -n "$priority" ] && [ -n "$target" ]; then
                  echo "**${priority}** ‚Üí ${target}"
                else
                  echo "$clean_val"
                fi
                ;;
              # For redirects: parse name=(code,source,target) format
              CLOUDFLAREAPI_SINGLE_REDIRECT)
                if echo "$value" | grep -q "name=("; then
                  local code=$(echo "$value" | sed -E 's/.*name=\(([0-9]+),.*/\1/')
                  local source=$(echo "$value" | sed -E 's/.*name=\([0-9]+,([^,]+),.*/\1/')
                  local target=$(echo "$value" | sed -E 's/.*name=\([0-9]+,[^,]+,([^)]+)\).*/\1/')
                  echo "**${code}**: ${source} ‚Üí ${target}"
                else
                  echo "$clean_val"
                fi
                ;;
              # For SRV records: parse priority weight port target
              SRV)
                local priority=$(echo "$clean_val" | awk '{print $1}')
                local weight=$(echo "$clean_val" | awk '{print $2}')
                local port=$(echo "$clean_val" | awk '{print $3}')
                local target=$(echo "$clean_val" | awk '{print $4}')
                if [ -n "$priority" ] && [ -n "$port" ] && [ -n "$target" ]; then
                  echo "**${priority}/${weight}** :${port} ‚Üí ${target}"
                else
                  echo "$clean_val"
                fi
                ;;
              # For CAA records: parse flags tag value
              CAA)
                local flags=$(echo "$clean_val" | awk '{print $1}')
                local tag=$(echo "$clean_val" | awk '{print $2}')
                local caa_value=$(echo "$clean_val" | awk '{$1=$2=""; print $0}' | sed 's/^ *//')
                if [ -n "$tag" ]; then
                  echo "**${tag}**: ${caa_value}"
                else
                  echo "$clean_val"
                fi
                ;;
              # For TXT records: format based on content type (SPF, DKIM, DMARC)
              TXT)
                # SPF record: v=spf1 ...
                if echo "$clean_val" | grep -q "^v=spf1"; then
                  local spf_flags=""      # a, mx, ptr (simple flags)
                  local spf_sources=""    # includes, ips, a:, mx:, exists:, redirect
                  local spf_all=""        # the all qualifier
                  for part in $clean_val; do
                    case "$part" in
                      v=spf1) ;;
                      a) spf_flags="${spf_flags:+$spf_flags / }A" ;;
                      mx) spf_flags="${spf_flags:+$spf_flags / }MX" ;;
                      ptr) spf_flags="${spf_flags:+$spf_flags / }PTR" ;;
                      a:*) spf_sources="${spf_sources:+$spf_sources / }A:\`${part#a:}\`" ;;
                      mx:*) spf_sources="${spf_sources:+$spf_sources / }MX:\`${part#mx:}\`" ;;
                      ptr:*) spf_sources="${spf_sources:+$spf_sources / }PTR:\`${part#ptr:}\`" ;;
                      include:*) spf_sources="${spf_sources:+$spf_sources / }\`${part#include:}\`" ;;
                      ip4:*) spf_sources="${spf_sources:+$spf_sources / }\`${part#ip4:}\`" ;;
                      ip6:*) spf_sources="${spf_sources:+$spf_sources / }\`${part#ip6:}\`" ;;
                      exists:*) spf_sources="${spf_sources:+$spf_sources / }exists:\`${part#exists:}\`" ;;
                      redirect=*) spf_sources="${spf_sources:+$spf_sources / }redirect:\`${part#redirect=}\`" ;;
                      +all) spf_all="\`+all\`" ;;
                      -all) spf_all="\`-all\`" ;;
                      ~all) spf_all="\`~all\`" ;;
                      \?all) spf_all="\`?all\`" ;;
                      *) [ -n "$part" ] && spf_sources="${spf_sources:+$spf_sources / }\`${part}\`" ;;
                    esac
                  done
                  # Build compact output
                  local spf_result="**SPF**"
                  # Combine flags and sources on one line
                  local spf_line=""
                  [ -n "$spf_flags" ] && spf_line="$spf_flags"
                  [ -n "$spf_sources" ] && spf_line="${spf_line:+$spf_line / }$spf_sources"
                  [ -n "$spf_line" ] && spf_result="${spf_result}<br>${spf_line}"
                  [ -n "$spf_all" ] && spf_result="${spf_result}<br>${spf_all}"
                  echo "$spf_result"
                # DKIM record: v=DKIM1; ...
                elif echo "$clean_val" | grep -q "^v=DKIM1"; then
                  # Extract all DKIM components
                  local dkim_k="" dkim_p="" dkim_t="" dkim_s="" dkim_h="" dkim_n=""
                  while IFS= read -r tag; do
                    tag=$(echo "$tag" | sed 's/^ *//' | sed 's/ *$//')
                    case "$tag" in
                      k=*) dkim_k="${tag#k=}" ;;
                      p=*) dkim_p="${tag#p=}" ;;
                      t=*) dkim_t="${tag#t=}" ;;
                      s=*) dkim_s="${tag#s=}" ;;
                      h=*) dkim_h="${tag#h=}" ;;
                      n=*) dkim_n="${tag#n=}" ;;
                    esac
                  done <<< "$(echo "$clean_val" | tr ';' '\n')"
                  # Build compact output
                  local dkim_result="**DKIM**"
                  # Flags line (t= and s= if present)
                  local dkim_flags=""
                  [ -n "$dkim_t" ] && dkim_flags="Flags:\`${dkim_t}\`"
                  [ -n "$dkim_s" ] && dkim_flags="${dkim_flags:+$dkim_flags / }Service:\`${dkim_s}\`"
                  [ -n "$dkim_flags" ] && dkim_result="${dkim_result}<br>${dkim_flags}"
                  # Key line: hash / key type / key (consolidated)
                  local dkim_key_line=""
                  [ -n "$dkim_h" ] && dkim_key_line=$(echo "$dkim_h" | tr '[:lower:]' '[:upper:]')
                  local key_type_upper=$(echo "${dkim_k:-rsa}" | tr '[:lower:]' '[:upper:]')
                  dkim_key_line="${dkim_key_line:+$dkim_key_line / }${key_type_upper}"
                  if [ -n "$dkim_p" ]; then
                    if [ ${#dkim_p} -gt 20 ]; then
                      dkim_key_line="${dkim_key_line} \`${dkim_p:0:16}...\`"
                    else
                      dkim_key_line="${dkim_key_line} \`${dkim_p}\`"
                    fi
                  fi
                  [ -n "$dkim_key_line" ] && dkim_result="${dkim_result}<br>${dkim_key_line}"
                  [ -n "$dkim_n" ] && dkim_result="${dkim_result}<br>Notes: ${dkim_n}"
                  echo "$dkim_result"
                # DMARC record: v=DMARC1; ...
                elif echo "$clean_val" | grep -q "^v=DMARC1"; then
                  # Extract all DMARC components
                  local dmarc_p="" dmarc_sp="" dmarc_adkim="" dmarc_aspf=""
                  local dmarc_pct="" dmarc_rua="" dmarc_ruf="" dmarc_fo="" dmarc_rf="" dmarc_ri=""
                  while IFS= read -r tag; do
                    tag=$(echo "$tag" | sed 's/^ *//' | sed 's/ *$//')
                    case "$tag" in
                      p=*) dmarc_p="${tag#p=}" ;;
                      sp=*) dmarc_sp="${tag#sp=}" ;;
                      adkim=*) dmarc_adkim="${tag#adkim=}" ;;
                      aspf=*) dmarc_aspf="${tag#aspf=}" ;;
                      pct=*) dmarc_pct="${tag#pct=}" ;;
                      rua=*) dmarc_rua="${tag#rua=}" ;;
                      ruf=*) dmarc_ruf="${tag#ruf=}" ;;
                      fo=*) dmarc_fo="${tag#fo=}" ;;
                      rf=*) dmarc_rf="${tag#rf=}" ;;
                      ri=*) dmarc_ri="${tag#ri=}" ;;
                    esac
                  done <<< "$(echo "$clean_val" | tr ';' '\n')"
                  # Build compact output
                  local dmarc_result="**DMARC**"
                  # Policy line: p / sp / pct
                  local dmarc_policy=""
                  [ -n "$dmarc_p" ] && dmarc_policy="Policy:\`${dmarc_p}\`"
                  [ -n "$dmarc_sp" ] && dmarc_policy="${dmarc_policy:+$dmarc_policy / }Subdomain:\`${dmarc_sp}\`"
                  [ -n "$dmarc_pct" ] && dmarc_policy="${dmarc_policy:+$dmarc_policy / }${dmarc_pct}%"
                  [ -n "$dmarc_policy" ] && dmarc_result="${dmarc_result}<br>${dmarc_policy}"
                  # Alignment line: adkim / aspf
                  local dmarc_align=""
                  [ -n "$dmarc_adkim" ] && dmarc_align="DKIM:\`${dmarc_adkim}\`"
                  [ -n "$dmarc_aspf" ] && dmarc_align="${dmarc_align:+$dmarc_align / }SPF:\`${dmarc_aspf}\`"
                  [ -n "$dmarc_align" ] && dmarc_result="${dmarc_result}<br>${dmarc_align}"
                  # Reports line: rua / ruf
                  local dmarc_reports=""
                  [ -n "$dmarc_rua" ] && dmarc_reports="rua:\`${dmarc_rua}\`"
                  [ -n "$dmarc_ruf" ] && dmarc_reports="${dmarc_reports:+$dmarc_reports / }ruf:\`${dmarc_ruf}\`"
                  [ -n "$dmarc_reports" ] && dmarc_result="${dmarc_result}<br>${dmarc_reports}"
                  # Options line: fo / rf / ri
                  local dmarc_opts=""
                  [ -n "$dmarc_fo" ] && dmarc_opts="fo:\`${dmarc_fo}\`"
                  [ -n "$dmarc_rf" ] && dmarc_opts="${dmarc_opts:+$dmarc_opts / }rf:\`${dmarc_rf}\`"
                  [ -n "$dmarc_ri" ] && dmarc_opts="${dmarc_opts:+$dmarc_opts / }ri:\`${dmarc_ri}s\`"
                  [ -n "$dmarc_opts" ] && dmarc_result="${dmarc_result}<br>${dmarc_opts}"
                  echo "$dmarc_result"
                else
                  # Other TXT records: show as-is
                  echo "$clean_val"
                fi
                ;;
              # For other types: apply reasonable truncation
              *)
                if [ ${#clean_val} -gt 100 ]; then
                  echo "${clean_val:0:97}..."
                else
                  echo "$clean_val"
                fi
                ;;
            esac
          }

          # Function to extract base domain (last two parts of FQDN)
          get_base_domain() {
            local domain="$1"
            local n
            n=$(echo "$domain" | tr '.' '\n' | wc -l)
            if [ "$n" -ge 2 ]; then
              echo "$domain" | awk -F'.' '{print $(NF-1)"."$NF}'
            else
              echo "$domain"
            fi
          }

          # Function to extract subdomain from full domain
          get_subdomain() {
            local full_domain="$1"
            local base_domain="$2"
            # Remove the base domain suffix to get subdomain
            local subdomain="${full_domain%.$base_domain}"
            if [ "$subdomain" = "$base_domain" ] || [ "$subdomain" = "$full_domain" ]; then
              # It's the apex record
              echo "**@** (apex)"
            elif [ "$subdomain" = "*" ]; then
              # It's a wildcard record
              echo "**\\*** (wildcard)"
            else
              echo "$subdomain"
            fi
          }

          # Create changes data with base domain info (pipe-separated: base|subdomain|type|action|old|new)
          CHANGES_DATA=""
          while IFS= read -r line; do
            # Parse CREATE lines: "#1: + CREATE domain.com TYPE value ttl=xxx"
            if echo "$line" | grep -qE "^#[0-9]+: \+ CREATE"; then
              DOMAIN=$(echo "$line" | sed -E 's/^#[0-9]+: \+ CREATE[[:space:]]+([^[:space:]]+)[[:space:]]+.*/\1/')
              RAW_TYPE=$(echo "$line" | sed -E 's/^#[0-9]+: \+ CREATE[[:space:]]+[^[:space:]]+[[:space:]]+([A-Z_]+)[[:space:]].*/\1/')
              RAW_VALUE=$(echo "$line" | sed -E 's/^#[0-9]+: \+ CREATE[[:space:]]+[^[:space:]]+[[:space:]]+[A-Z_]+[[:space:]]+(.*)/\1/' | sed 's/ttl=[0-9]*//' | tr -d '"')
              TYPE=$(simplify_type "$RAW_TYPE")
              VALUE=$(clean_value "$RAW_TYPE" "$RAW_VALUE" "$DOMAIN")
              BASE=$(get_base_domain "$DOMAIN")
              SUBDOMAIN=$(get_subdomain "$DOMAIN" "$BASE")
              CHANGES_DATA="${CHANGES_DATA}${BASE}|${SUBDOMAIN}|${TYPE}|‚ûï|-|${VALUE}"$'\n'
            # Parse MODIFY lines: "#1: ¬± MODIFY domain.com TYPE (old) -> (new)"
            elif echo "$line" | grep -qE "^#[0-9]+: ¬± MODIFY"; then
              DOMAIN=$(echo "$line" | sed -E 's/^#[0-9]+: ¬± MODIFY[[:space:]]+([^[:space:]]+)[[:space:]]+.*/\1/')
              RAW_TYPE=$(echo "$line" | sed -E 's/^#[0-9]+: ¬± MODIFY[[:space:]]+[^[:space:]]+[[:space:]]+([A-Z_]+)[[:space:]].*/\1/')
              OLD=$(echo "$line" | sed -E 's/.*\(([^)]+)\)[[:space:]]*->.*/\1/' | tr -d '"')
              NEW=$(echo "$line" | sed -E 's/.*->[[:space:]]*\(([^)]+)\).*/\1/' | tr -d '"')
              TYPE=$(simplify_type "$RAW_TYPE")
              OLD=$(clean_value "$RAW_TYPE" "$OLD" "$DOMAIN")
              NEW=$(clean_value "$RAW_TYPE" "$NEW" "$DOMAIN")
              BASE=$(get_base_domain "$DOMAIN")
              SUBDOMAIN=$(get_subdomain "$DOMAIN" "$BASE")
              CHANGES_DATA="${CHANGES_DATA}${BASE}|${SUBDOMAIN}|${TYPE}|‚úèÔ∏è|${OLD}|${NEW}"$'\n'
            # Parse DELETE lines: "#1: - DELETE domain.com TYPE value"
            elif echo "$line" | grep -qE "^#[0-9]+: - DELETE"; then
              DOMAIN=$(echo "$line" | sed -E 's/^#[0-9]+: - DELETE[[:space:]]+([^[:space:]]+)[[:space:]]+.*/\1/')
              RAW_TYPE=$(echo "$line" | sed -E 's/^#[0-9]+: - DELETE[[:space:]]+[^[:space:]]+[[:space:]]+([A-Z_]+)[[:space:]].*/\1/')
              RAW_VALUE=$(echo "$line" | sed -E 's/^#[0-9]+: - DELETE[[:space:]]+[^[:space:]]+[[:space:]]+[A-Z_]+[[:space:]]+(.*)/\1/' | sed 's/ttl=[0-9]*//' | tr -d '"')
              TYPE=$(simplify_type "$RAW_TYPE")
              VALUE=$(clean_value "$RAW_TYPE" "$RAW_VALUE" "$DOMAIN")
              BASE=$(get_base_domain "$DOMAIN")
              SUBDOMAIN=$(get_subdomain "$DOMAIN" "$BASE")
              CHANGES_DATA="${CHANGES_DATA}${BASE}|${SUBDOMAIN}|${TYPE}|üóëÔ∏è|${VALUE}|-"$'\n'
            fi
          done <<< "$CLEAN_OUTPUT"

          # Sort by: 1) base domain, 2) record type, 3) subdomain
          if [ -n "$CHANGES_DATA" ]; then
            SORTED_DATA=$(echo "$CHANGES_DATA" | sort -t'|' -k1,1 -k3,3 -k2,2)
          else
            SORTED_DATA=""
          fi

          # Get unique base domains (sorted)
          BASE_DOMAINS=$(echo "$SORTED_DATA" | cut -d'|' -f1 | sort -u | grep -v '^$')

          # Build domain summary (base domain -> add/modify/delete counts)
          DOMAIN_SUMMARY=""
          for base in $BASE_DOMAINS; do
            ADD_COUNT=$(echo "$SORTED_DATA" | grep "^${base}|" | grep -c '|‚ûï|' || echo 0)
            MOD_COUNT=$(echo "$SORTED_DATA" | grep "^${base}|" | grep -c '|‚úèÔ∏è|' || echo 0)
            DEL_COUNT=$(echo "$SORTED_DATA" | grep "^${base}|" | grep -c '|üóëÔ∏è|' || echo 0)
            DOMAIN_SUMMARY="${DOMAIN_SUMMARY}${base}|${ADD_COUNT}|${MOD_COUNT}|${DEL_COUNT}"$'\n'
          done

          # Output domain summary for comment generation
          echo "domain-summary<<EOF" >> $GITHUB_OUTPUT
          echo "$DOMAIN_SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Output sorted changes data for comment generation
          echo "changes-data<<EOF" >> $GITHUB_OUTPUT
          echo "$SORTED_DATA" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Output base domains list for iteration
          echo "base-domains<<EOF" >> $GITHUB_OUTPUT
          echo "$BASE_DOMAINS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload preview output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: preview-output
          path: preview-output.txt
          retention-days: 1
          if-no-files-found: ignore

  comment:
    name: Update PR Comment
    needs: [validate, prepare, preview]
    if: always() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          sparse-checkout: packages/polaris-dns/src/zones

      - name: Extract known domains
        id: domains
        run: |
          # Extract domain names from zone file names (excluding index.ts)
          # File pattern: domain-name.ts -> domain.name
          DOMAINS=$(find packages/polaris-dns/src/zones -name "*.ts" ! -name "index.ts" -type f \
            | xargs -n1 basename \
            | sed 's/\.ts$//' \
            | sed 's/-\([^-]*\)$/.\1/' \
            | sort)
          echo "list<<EOF" >> $GITHUB_OUTPUT
          echo "$DOMAINS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Download preview output
        uses: actions/download-artifact@v4
        with:
          name: preview-output
          path: .
        continue-on-error: true

      - name: Find existing PR comment
        id: find-comment
        uses: peter-evans/find-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-author: "github-actions[bot]"
          body-includes: "<!-- dns-preview-comment -->"

      - name: Extract existing status rows
        id: existing-rows
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          COMMENT_ID: ${{ steps.find-comment.outputs.comment-id }}
          REPO: ${{ github.repository }}
        run: |
          # Fetch comment body via GitHub API to avoid "Argument list too long" error
          # The comment body can be very large with many commits tracked
          if [ -n "$COMMENT_ID" ] && [ "$COMMENT_ID" != "" ]; then
            gh api "/repos/${REPO}/issues/comments/${COMMENT_ID}" --jq '.body' > existing-comment.txt 2>/dev/null || echo "" > existing-comment.txt
          else
            echo "" > existing-comment.txt
          fi

          # Extract existing status table rows (excluding header)
          # Expected format: | Commit | Build | Test | Validate | Preview | Changes | (6 columns = 7 pipes)
          if [ -s "existing-comment.txt" ]; then
            # Extract rows between the table header separator and the next section
            RAW_ROWS=$(cat existing-comment.txt | sed -n '/^|--------|/,/^$/p' | grep "^| \[" || echo "")

            # Filter to only include rows with the correct number of columns (7 pipes for 6 columns)
            VALID_ROWS=""
            while IFS= read -r row; do
              if [ -n "$row" ]; then
                PIPE_COUNT=$(echo "$row" | tr -cd '|' | wc -c)
                if [ "$PIPE_COUNT" -eq 7 ]; then
                  VALID_ROWS="${VALID_ROWS}${row}"$'\n'
                fi
              fi
            done <<< "$RAW_ROWS"

            echo "rows<<EOF" >> $GITHUB_OUTPUT
            echo "$VALID_ROWS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "rows=" >> $GITHUB_OUTPUT
          fi

      - name: Generate comment content
        id: comment
        shell: bash
        env:
          VALIDATE_RESULT: ${{ needs.validate.outputs.validate-result }}
          VALIDATE_PACKAGES: ${{ needs.validate.outputs.validate-packages }}
          PREPARE_RESULT: ${{ needs.prepare.result }}
          PREVIEW_RESULT: ${{ needs.preview.result }}
          HAS_CHANGES: ${{ needs.preview.outputs.has-changes }}
          CHANGES_SUMMARY: ${{ needs.preview.outputs.changes-summary }}
          DOMAIN_SUMMARY: ${{ needs.preview.outputs.domain-summary }}
          CHANGES_DATA: ${{ needs.preview.outputs.changes-data }}
          BASE_DOMAINS: ${{ needs.preview.outputs.base-domains }}
          ALL_KNOWN_DOMAINS: ${{ steps.domains.outputs.list }}
          BUILD_PACKAGES: ${{ needs.prepare.outputs.build-packages }}
          TEST_RESULT: ${{ needs.validate.outputs.test-result }}
          TEST_PACKAGES: ${{ needs.validate.outputs.test-packages }}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha }}
          RUN_ID: ${{ github.run_id }}
          REPO: ${{ github.repository }}
          EXISTING_ROWS: ${{ steps.existing-rows.outputs.rows }}
        run: |
          # Read preview output from artifact file (avoids "Argument list too long" error)
          if [ -f "preview-output.txt" ]; then
            PREVIEW_OUTPUT=$(cat preview-output.txt)
          else
            PREVIEW_OUTPUT=""
          fi

          # Generate status icons
          get_icon() {
            if [ "$1" == "success" ]; then echo "‚úÖ"; else echo "‚ùå"; fi
          }

          BUILD_ICON=$(get_icon "$PREPARE_RESULT")
          TEST_ICON=$(get_icon "$TEST_RESULT")
          VALIDATE_ICON=$(get_icon "$VALIDATE_RESULT")
          PREVIEW_ICON=$(get_icon "$PREVIEW_RESULT")

          # Changes icon and text
          if [ "$PREVIEW_RESULT" != "success" ]; then
            CHANGES_ICON="‚ùå"
            CHANGES_TEXT="Preview failed"
          elif [ "$HAS_CHANGES" == "true" ]; then
            CHANGES_ICON=""
            CHANGES_TEXT="${CHANGES_SUMMARY:-Changes detected}"
          else
            CHANGES_ICON="‚úÖ"
            CHANGES_TEXT="no changes"
          fi

          # Short commit SHA
          SHORT_SHA="${COMMIT_SHA:0:7}"

          # Create new status row (order: Build > Test > Validation > Preview)
          NEW_ROW="| [\`$SHORT_SHA\`](https://github.com/$REPO/actions/runs/$RUN_ID) | $BUILD_ICON | $TEST_ICON | $VALIDATE_ICON | $PREVIEW_ICON | $CHANGES_ICON $CHANGES_TEXT |"

          # Build the comment using echo statements
          {
            echo "<!-- dns-preview-comment -->"
            echo "## üïí PR History"
            echo ""
            echo "| Commit | Build | Test | Validate | Preview | Changes |"
            echo "|--------|-------|------|----------|---------|---------|"
            # Output existing rows first (oldest), then new row (newest) - chronological order
            if [ -n "$EXISTING_ROWS" ]; then
              # Strip trailing newlines/whitespace to avoid blank lines in table
              printf '%s\n' "$(echo "$EXISTING_ROWS" | sed -e 's/[[:space:]]*$//')"
            fi
            echo "$NEW_ROW"
            echo ""
            echo "# üî® Run Results"
            echo ""
            echo "| Package | Build | Typecheck | Lint | Format |"
            echo "|---------|-------|-----------|------|--------|"

            # Combine build and validation packages into one table
            # First, collect all package names from both sources
            ALL_PACKAGES=""
            if [ -n "$BUILD_PACKAGES" ] && [ "$BUILD_PACKAGES" != "{}" ]; then
              BUILD_PKGS=$(echo "$BUILD_PACKAGES" | jq -r 'keys[]')
              ALL_PACKAGES="$BUILD_PKGS"
            fi
            if [ -n "$VALIDATE_PACKAGES" ] && [ "$VALIDATE_PACKAGES" != "[]" ]; then
              VALIDATE_PKGS=$(echo "$VALIDATE_PACKAGES" | jq -r '.[].name')
              if [ -n "$ALL_PACKAGES" ]; then
                ALL_PACKAGES=$(printf '%s\n%s' "$ALL_PACKAGES" "$VALIDATE_PKGS" | sort -u)
              else
                ALL_PACKAGES="$VALIDATE_PKGS"
              fi
            fi

            # Generate rows for each package
            if [ -n "$ALL_PACKAGES" ]; then
              echo "$ALL_PACKAGES" | while IFS= read -r pkg; do
                [ -z "$pkg" ] && continue
                # Get short package name (remove @vladzaharia/ prefix)
                SHORT_PKG=$(echo "$pkg" | sed 's/@vladzaharia\///')

                # Get build status
                BUILD_STATUS=""
                if [ -n "$BUILD_PACKAGES" ] && [ "$BUILD_PACKAGES" != "{}" ]; then
                  BUILD_STATUS=$(echo "$BUILD_PACKAGES" | jq -r --arg p "$pkg" '.[$p] // empty')
                fi
                BUILD_ICON=$(if [ "$BUILD_STATUS" == "success" ]; then echo "‚úÖ"; elif [ -n "$BUILD_STATUS" ]; then echo "‚ùå"; else echo "-"; fi)

                # Get validation statuses
                TYPECHECK_STATUS=""
                LINT_STATUS=""
                FORMAT_STATUS=""
                if [ -n "$VALIDATE_PACKAGES" ] && [ "$VALIDATE_PACKAGES" != "[]" ]; then
                  VALIDATE_DATA=$(echo "$VALIDATE_PACKAGES" | jq -r --arg p "$pkg" '.[] | select(.name == $p)')
                  if [ -n "$VALIDATE_DATA" ]; then
                    TYPECHECK_STATUS=$(echo "$VALIDATE_DATA" | jq -r '.typecheck // empty')
                    LINT_STATUS=$(echo "$VALIDATE_DATA" | jq -r '.lint // empty')
                    FORMAT_STATUS=$(echo "$VALIDATE_DATA" | jq -r '.format // empty')
                  fi
                fi
                TYPECHECK_ICON=$(if [ "$TYPECHECK_STATUS" == "success" ]; then echo "‚úÖ"; elif [ -n "$TYPECHECK_STATUS" ]; then echo "‚ùå"; else echo "-"; fi)
                LINT_ICON=$(if [ "$LINT_STATUS" == "success" ]; then echo "‚úÖ"; elif [ -n "$LINT_STATUS" ]; then echo "‚ùå"; else echo "-"; fi)
                FORMAT_ICON=$(if [ "$FORMAT_STATUS" == "success" ]; then echo "‚úÖ"; elif [ -n "$FORMAT_STATUS" ]; then echo "‚ùå"; else echo "-"; fi)

                echo "| $SHORT_PKG | $BUILD_ICON | $TYPECHECK_ICON | $LINT_ICON | $FORMAT_ICON |"
              done
            else
              echo "| No packages | - | - | - | - |"
            fi
            echo ""
            echo "## üß™ Tests"
            echo ""
            echo "| Package | Total | Passed | Failed | Skipped | Status |"
            echo "|---------|-------|--------|--------|---------|--------|"

            # Parse test packages JSON and generate rows
            if [ -n "$TEST_PACKAGES" ] && [ "$TEST_PACKAGES" != "[]" ]; then
              echo "$TEST_PACKAGES" | jq -r '.[] | "\(.name)|\(.total)|\(.passed)|\(.failed)|\(.skipped)|\(.status)"' | while IFS='|' read -r pkg total passed failed skipped status; do
                # Get short package name (remove @vladzaharia/ prefix)
                SHORT_PKG=$(echo "$pkg" | sed 's/@vladzaharia\///')
                PKG_ICON=$(if [ "$status" == "success" ]; then echo "‚úÖ"; else echo "‚ùå"; fi)
                echo "| $SHORT_PKG | $total | $passed | $failed | $skipped | $PKG_ICON |"
              done
            else
              echo "| No tests | 0 | 0 | 0 | 0 | - |"
            fi

            echo ""
            echo "# üåê DNS Changes"
            echo ""
            if [ "$PREVIEW_RESULT" != "success" ]; then
              echo "**Summary:** ‚ùå Preview completed with errors"
              echo ""
              echo "> [!WARNING]"
              echo "> The DNS preview step failed. Check the output below for details."
            else
              echo "**Summary:** ${CHANGES_SUMMARY:-No changes}"
              echo ""

              # Domain Summary Table
              if [ -n "$DOMAIN_SUMMARY" ] && [ "$DOMAIN_SUMMARY" != "" ]; then
                echo "| Domain | ‚ûï Additions | ‚úèÔ∏è Changes | üóëÔ∏è Deletions |"
                echo "|--------|-------------|-----------|--------------|"
                echo "$DOMAIN_SUMMARY" | while IFS='|' read -r domain adds mods dels; do
                  [ -z "$domain" ] && continue
                  echo "| \`$domain\` | $adds | $mods | $dels |"
                done
                echo ""
              fi

              # Per-domain detail sections (uses ALL_KNOWN_DOMAINS from env, extracted from zone files)
              for domain in $ALL_KNOWN_DOMAINS; do
                # Check if this domain has any changes
                DOMAIN_CHANGES=$(echo "$CHANGES_DATA" | grep "^${domain}|" || echo "")

                echo "<details>"
                if [ -n "$DOMAIN_CHANGES" ]; then
                  # Count changes for this domain
                  ADDS=$(echo "$DOMAIN_CHANGES" | grep -c '|‚ûï|' || echo 0)
                  MODS=$(echo "$DOMAIN_CHANGES" | grep -c '|‚úèÔ∏è|' || echo 0)
                  DELS=$(echo "$DOMAIN_CHANGES" | grep -c '|üóëÔ∏è|' || echo 0)
                  TOTAL=$((ADDS + MODS + DELS))
                  echo "<summary><strong>$domain</strong> ($TOTAL change$( [ $TOTAL -ne 1 ] && echo 's'))</summary>"
                  echo ""
                  echo "| Type | Name | Record | Old Value | New Value |"
                  echo "|------|------|--------|-----------|-----------|"
                  # Output changes for this domain (already sorted by type, then name)
                  echo "$DOMAIN_CHANGES" | while IFS='|' read -r base subdomain rectype action old new; do
                    [ -z "$base" ] && continue
                    echo "| $action | $subdomain | $rectype | $old | $new |"
                  done
                else
                  echo "<summary><strong>$domain</strong> (no changes)</summary>"
                  echo ""
                  echo "_No changes to this domain._"
                fi
                echo ""
                echo "</details>"
                echo ""
              done
            fi
            echo ""
            echo "<details>"
            echo "<summary>üìã Full DNSControl Output</summary>"
            echo ""
            echo "\`\`\`"
            # Truncate output to prevent excessively large comments (max ~50KB)
            MAX_OUTPUT_LINES=500
            OUTPUT_LINES=$(echo "${PREVIEW_OUTPUT:-No output available}" | wc -l)
            if [ "$OUTPUT_LINES" -gt "$MAX_OUTPUT_LINES" ]; then
              echo "${PREVIEW_OUTPUT}" | head -n "$MAX_OUTPUT_LINES"
              echo ""
              echo "... (truncated, $OUTPUT_LINES total lines - see workflow logs for full output)"
            else
              echo "${PREVIEW_OUTPUT:-No output available}"
            fi
            echo "\`\`\`"
            echo ""
            echo "</details>"
            echo ""
            echo "---"
            echo "*Latest commit: \`$COMMIT_SHA\`* | [View Run](https://github.com/$REPO/actions/runs/$RUN_ID)"
          } > comment.md

      - name: Create or update PR comment
        uses: marocchino/sticky-pull-request-comment@v2.9.4
        with:
          header: dns-preview
          path: comment.md
